<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{A Markdown Vignette with knitr}
-->

```{r setup, include=FALSE}
library(knitr)
render_html()
options(width=120)
opts_chunk$set(fig.path="figure/", cache.path="cache/", fig.align="center", warning=FALSE, message=FALSE, fig.height=7, fig.width=5)
```

Introduction to XML2R package
====================================

Extracting observations
--------------------------

The  [XML2R package](https://github.com/cpsievert/XML2R) is meant to simplify scraping [XML](http://en.wikipedia.org/wiki/XML) data from XML files hosted on the web. The main function, `XML2Obs`, coerces XML content into a list of _observations_. Here we define an _observation_ as a matrix with one row. One observation will contain all attributes and the XML value for a particular XML lineage. The name of each list element (or each observation) tracks the XML hierarchy so observations can be grouped together in a sensible fashion at a later point. In the code below, we obtain 946 observations from two different XML files that contain data on [Major League Baseball](http://en.wikipedia.org/wiki/Major_League_Baseball) games played on June 14th, 2013.

```{r ex1, tidy=FALSE, results='hide'}
library(XML2R)
pre <- "http://gd2.mlb.com/components/game/mlb/year_2013/month_06/day_14/"
post <- c("gid_2013_06_14_phimlb_colmlb_1/inning/inning_all.xml",
          "gid_2013_06_14_seamlb_oakmlb_1/inning/inning_all.xml")
urls <- paste0(pre, post)
obs <- XML2Obs(urls)
```

```{r n}
length(obs)
```

Note that the length of the `obs` object is one longer than the true number of observations. That's because an element (named url_map) containing all the relevant file names will be appended to the end of the list. The values in this list can be used to link to the `url_key` variable back to the exact file name. This structuring helps us avoid unnecesarily repeating long file names in every observation.

```{r str}
tail(obs, 3)
```

As seen in the output above, the last observation happens at the game level while the second observation happens at the game//inning level. Of course, we can have many observations that belong to a particular level. To get a feel for how many levels we have (and their naming), we can use:

```{r levels}
lvls <- unique(names(obs))
lvls
```

Renaming observations
--------------------------

Eventually we'll want to combine observations from the same level into a common table/matrix/data.frame. Before that, we may want to regard two different levels as equivalent. For example, I know that observations at the "game//inning//top//atbat"  level are essentially the same as observations at the "game//inning//bottom//atbat" level. I may want to `rename` these observations as "game//inning//atbat" and append a variable for each relevant observation that tracks whether the atbat occured at the "top" or "bottom" of the inning.

```{r rename, message=FALSE}
tmp <- rename(obs, equiv=c("game//inning//top//atbat", "game//inning//bottom//atbat")) 
```

In this case, there is good reason to do this renaming for any name containing "pitch", "runner", "action", or "po".

```{r rename2, message=FALSE}
pitch <- lvls[grep("pitch", lvls)]
tmp <- rename(tmp, equiv=pitch, diff.name="inning") 
runner <- lvls[grep("runner", lvls)]
tmp <- rename(tmp, equiv=runner, diff.name="inning") 
action <- lvls[grep("action", lvls)]
tmp <- rename(tmp, equiv=action, diff.name="inning")  
po <- lvls[grep("po", lvls)]
obs2 <- rename(tmp, equiv=po, diff.name="inning")
unique(names(obs2))
```

Linking observations
----------------------------

After all that renaming, we now have data on `r length(unique(names(obs2)))-1` different levels. Next, we may want to pool together observations from a common level into a table. Note that is also important that we have an option to link a child observation back to it's parent. For example, I may want to link a particular pitch (that is, an observation from the "game//inning//atbat//pitch" level) back to the relevant atbat (that is, an observation from the "game//inning//atbat" level).

To help link children back to parents, we can use the `add_key` function. Here I will use `add_key` to create a link between an observation at the "game//inning" level and it's children. A similar link is also created to link observations at the "game//inning//atbat" level to it's children. Note that links are just another variable that is appended to relevant observations. Here I am naming those variables "inning_key" and "atbat_key". This linking works assuming that the ordering of observations is preserved from the output of `XML2Obs` (which preserves the ordering in the original document(s)).

```{r add_key, message=FALSE}
tmp2 <- add_key(obs2, parent="game//inning", key.name="inning_key")
obswkey <- add_key(tmp2, parent="game//inning//atbat", key.name="atbat_key")
```

Collapsing observations
----------------------------

Finally, we are in a position to pool together observations that have a common name. The `collapse` function achieves this by row binding observations together and returning a list of matrices. Note that `collapse` doesn't require that observations from the same level to have the same set of variables. In the case where variables are missing, `NA`s will be used as the value.

```{r collapse}
tables <- collapse(obswkey)
head(tables[["game//inning//atbat//po"]])
```

At this point, you are probably ready to save this data structure using your favorite method. I strongly recommend writing `tables` to a database if you plan on repeatedly querying your data. 

Using XPath
--------------------------

If one is interested in just a subset of the XML document, the `xpath` option of `XML2Obs` can be used to specify [XPath syntax](http://www.w3schools.com/xpath/xpath_syntax.asp). Suppose for some reason I only want data that occurs on the "game//inning//bottom" level. 

```{r xpath, results='hide'}
dat2 <- XML2Obs(urls, xpath="/game/inning/bottom")
```

```{r xpath1}
unique(names(dat2))
```
